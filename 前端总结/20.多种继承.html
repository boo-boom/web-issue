<!DOCTYPE html>
<html lang="zh-cmn-Hans">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Document</title>
  </head>
  <body></body>
  <script>
    /**
     * 原型链继承
     *    缺点：
     *      1. 子类实例化时无法向父类传参
     *      2. 引用类型的属性被所有实例共享
     */
    function Obj1(nike) {
      this.name = "Obj1";
      this.nike = nike; // 子类实例化时无法传入该参数
      this.arr = [1, 2];
    }
    Obj1.prototype.getName = function() {
      console.log(this.name);
    };
    function Child1() {}
    Child1.prototype = new Obj1();
    var c1_1 = new Child1();
    var c1_2 = new Child1();
    c1_1.getName();
    c1_1.arr.push(3); // 属性为饮用类型时，该属性在多个实例中指向一致

    console.log(c1_1.name, c1_1.nike, c1_1.arr, c1_2.arr);

    /**
     * 构造函数继承：复制父类构造函数内的属性
     *    优点：
     *      1. 避免了引用类型的属性被所有实例共享
     *      2. 可以在Child中向Parent传参
     *    缺点：
     *      1. c2_1 instanceof Obj2 => false 无法识别是父级的实例
     *      2. 方法都在构造函数中定义，每次创建实例都会创建一遍方法
     */
    function Obj2(name) {
      this.name = name;   // 可以利用构造函数向父级传参
      this.arr = [1, 2];
    }
    Obj2.prototype.getName = function() {
      console.log(this.name);
    };
    function Child2(name) {
      Obj2.call(this, name);
    }
    var c2_1 = new Child2("Obj2_1");
    var c2_2 = new Child2("Obj2_2");
    c2_1.arr.push(3);     // 引用类型属性不会被公用
    console.log(c2_1, c2_2, c2_1 instanceof Obj2);

    /**
     * 组合继承: 组合 原型链继承 和 借用构造函数继承
     *    使用原型链实现对原型方法的继承，而通过借用构造函数来实现对实例属性的继承
     *    优点：融合原型链继承和构造函数的优点，是JavaScript中最常用的继承模式
     *    缺点：调用了两次父类构造函数 => 组合继承最大的问题是无论什么情况下，都会调用两次超类型构造函数：一次是在创建子类型原型的时候，另一次是在子类型构造函数内部
     */
    function Obj3(name) {
      this.name = name;
      this.arr = [1, 2];
    }
    Obj3.prototype.getName = function() {
      console.log(this.name);
    };
    function Child3(name) {
      Obj3.call(this, name);    // 第二次调用 Obj3()
    }
    Child3.prototype = new Obj3();    // 第一次调用 Obj3()
    var c3_1 = new Obj3("Obj3_1");
    var c3_2 = new Obj3("Obj3_2");
    c3_1.arr.push(3);
    c3_1.getName();
    c3_2.getName();
    console.log(c3_1, c3_2, c3_1 instanceof Obj3);

    /**
     * 原型式继承
     */
    function Created(obj) {
      function F();
      F.prototype = obj;
      return new F();
    }

  </script>
</html>
